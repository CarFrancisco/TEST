{"CLs":[{"__type":"LD","Var":"Enable"},{"__type":"LD","Ix":1,"Var":"MyTS.Enable","X":1},{"__type":"F","In":[{"__type":"PF","Arg":"EN"},{"__type":"PRM","Arg":"In1","Ix":5,"Type":"ANY_ELEMENTARY(except BOOL)","Var":"MyTS.Num"},{"__type":"PRM","Arg":"In2","Ix":6,"Type":"ANY_ELEMENTARY(except BOOL)","Var":"UINT#0"}],"Ix":11,"Name":">","Out":[{"__type":"PF","Arg":""}],"X":2,"PL":true},{"__type":"ST","Ix":3,"Var":"ENO","X":3},{"__type":"LD","Ix":2,"Var":"MyTS.Cfg.DualOutput","X":3,"Y":1},{"__type":"F","In":[{"__type":"PF","Arg":"EN"},{"__type":"PRM","Arg":"In1","Ix":7,"Type":"ANY_ELEMENTARY, ENUM","Var":"MyTS.Switchs[0].Stp"},{"__type":"PRM","Arg":"In2","Ix":8,"Type":"ANY_ELEMENTARY, ENUM","Var":"USINT#2"}],"Ix":12,"Name":"=","Out":[{"__type":"PF","Arg":""}],"X":4,"Y":1,"PL":true},{"__type":"F","In":[{"__type":"PF","Arg":"EN"},{"__type":"PRM","Arg":"In1","Ix":9,"Type":"ANY_ELEMENTARY, ENUM","Var":"MyTS.Switchs[0].Stp"},{"__type":"PRM","Arg":"In2","Ix":10,"Type":"ANY_ELEMENTARY, ENUM","Var":"USINT#4"}],"Ix":13,"Name":"=","Out":[{"__type":"PF","Arg":""}],"X":4,"Y":2,"PL":true},{"__type":"ST","Ix":4,"Var":"Run_Dual","X":5,"Y":1},{"__type":"HL","X":4},{"__type":"HL","X":5}],"CMT":"_______________________________________________________________________________________________________\u000a¦   Timestamp compensation order                                                                                                    ¦\u000a¦______________________________________________________________________________________________________¦\u000a\u000d\u000aCheck if a switch is programmed and compenation used","LRI":14,"RRI":15,"VLs":[{"Ix":16,"X":3},{"Ix":17,"X":4,"Y":1},{"Ix":18,"X":5,"Y":1}]}
{"CLs":[{"__type":"LD","Var":"ENO"},{"__type":"LD","Ix":1,"Var":"MyTS.Cfg.SingleOutput","X":1},{"__type":"F","In":[{"__type":"PF","Arg":"EN"},{"__type":"PRM","Arg":"In1","Ix":7,"Type":"ANY_ELEMENTARY, ENUM","Var":"MyTS.Switchs[0].Stp"},{"__type":"PRM","Arg":"In2","Ix":8,"Type":"ANY_ELEMENTARY, ENUM","Var":"USINT#2"}],"Ix":11,"Name":"=","Out":[{"__type":"PF","Arg":""}],"X":2,"PL":true},{"__type":"LD","Ix":3,"Var":"Run_Dual","X":1,"Y":1},{"__type":"HL","X":2,"Y":1},{"__type":"ST","Ix":5,"Var":"Update_On","X":3},{"__type":"LD","Ix":2,"Var":"MyTS.Cfg.SingleOutput","X":1,"Y":2},{"__type":"F","In":[{"__type":"PF","Arg":"EN"},{"__type":"PRM","Arg":"In1","Ix":9,"Type":"ANY_ELEMENTARY, ENUM","Var":"MyTS.Switchs[0].Stp"},{"__type":"PRM","Arg":"In2","Ix":10,"Type":"ANY_ELEMENTARY, ENUM","Var":"USINT#4"}],"Ix":12,"Name":"=","Out":[{"__type":"PF","Arg":""}],"X":2,"Y":2,"PL":true},{"__type":"LD","Ix":4,"Var":"Run_Dual","X":1,"Y":3},{"__type":"HL","X":2,"Y":3},{"__type":"ST","Ix":6,"Var":"Update_Off","X":3,"Y":2}],"CMT":"Check witch compensation must be computed","LRI":13,"RRI":14,"VLs":[{"Ix":15,"X":1},{"Ix":15,"X":1,"Y":1},{"Ix":15,"X":1,"Y":2},{"Ix":16,"X":3},{"Ix":17,"X":3,"Y":2}]}
{"CLs":[{"__type":"LD","Var":"ENO"},{"__type":"LD","Ix":1,"Var":"MyTS.Wrap","X":1},{"__type":"IST","EID":"abf226c9-2608-4293-aa5d-8f98d5f2b574","H":209,"Ix":2,"TXT":"\/\/ Wrap around start switch\u000d\u000aIF MyTS.Switchs[0].PosStart > MyTS.Cfg.Modulo THEN\u000d\u000a\u0009MyTS.Switchs[0].PosStart := MyTS.Switchs[0].PosStart - MyTS.Cfg.Modulo;\u000d\u000aEND_IF;\u000d\u000a\u000d\u000a\/\/ Wrap around end switch\u000d\u000aIF MyTS.Switchs[0].PosEnd > MyTS.Cfg.Modulo THEN\u000d\u000a\u0009MyTS.Switchs[0].PosEnd := MyTS.Switchs[0].PosEnd - MyTS.Cfg.Modulo;\u000d\u000aEND_IF;","W":930,"X":2}],"CMT":"The switchs can be created at value higher than modulo. It's not an issue for the first timestamp computation, the time will be positive!\u000d\u000aBut during a recomputation of TS, having a wrap around will change the travel distance, so we need to substracte à modulo the get the correct travel distance left","LRI":3,"RRI":4,"VLs":[]}
{"CLs":[{"__type":"LD","Id":"6953811b-6bf0-4fed-84b0-8da50000002f","Up":true,"Var":"Update_On"},{"__type":"IST","EID":"8ecaef73-3908-4fea-835c-9630a6f20bc5","H":192,"Ix":1,"TXT":"\/\/ Position is bigger than modulo \u000d\u000aIF MyTS.Switchs[0].PosStart > MyTS.Cfg.Modulo THEN\u000d\u000a\u0009IF MyTS.Act.Pos < 100 THEN\u000d\u000a\u0009\u0009MyTS.Switchs[0].PosStart := MyTS.Switchs[0].PosStart - MyTS.Cfg.Modulo;\u000d\u000a\u0009END_IF;\u000d\u000aEND_IF;\u000d\u000a\u000d\u000aAvgTS_On := 0;","W":934.99999999999989,"X":1}],"CMT":"If not lucky, the wrap append one cycle before the starting switch.\u000d\u000aSo if the PosStart is bigger than the module AND the actual position is already wrapped, we need to substract the module","LRI":2,"RRI":3,"VLs":[]}
{"CLs":[{"__type":"LD","Id":"6953811b-6bf0-4fed-84b0-8da500000034","Up":true,"Var":"Update_Off"},{"__type":"IST","EID":"c764a434-f264-42e8-b4b5-b4c62bf044f0","H":192,"Ix":1,"TXT":"\/\/ Position is bigger than modulo \u000d\u000aIF MyTS.Switchs[0].PosEnd > MyTS.Cfg.Modulo THEN\u000d\u000a\u0009IF MyTS.Act.Pos < 100 THEN\u000d\u000a\u0009MyTS.Switchs[0].PosEnd := MyTS.Switchs[0].PosEnd - MyTS.Cfg.Modulo;\u000d\u000a\u0009END_IF;\u000d\u000aEND_IF;\u000d\u000a\u000d\u000aAvgTS_Off := 0;","W":937.99999999999989,"X":1}],"CMT":"Same problem with PosEnd? (Not sure, because it will be later)","LRI":2,"RRI":3,"VLs":[]}
{"CLs":[{"__type":"LD","Var":"Update_On"},{"__type":"IST","EID":"c477227e-410a-434e-bd91-3b6d50cbff66","H":681.00000000000011,"Ix":1,"TXT":"\/\/ Get the travel distance left to SET the output\u000d\u000aTravel_Dist_On := MyTS.Switchs[0].PosStart - MyTS.Act.Pos;\u000d\u000a\u000d\u000a\/\/ v01: Check if travel distance is calculed during a wrap-around\u000d\u000aIF Travel_Dist_On > MyTS.Cfg.Modulo THEN\u000d\u000a\u0009Travel_Dist_On := Travel_Dist_On - MyTS.Cfg.Modulo;\u000d\u000aEND_IF;\u000d\u000a\u000d\u000a\/\/\/\/\/\/\/\/ Debug\u000d\u000aMyTS.Debug.Real_1 :=Travel_Dist_On;\u000d\u000a\u000d\u000a\/\/ Travel distance must be positive\u000d\u000aIF Travel_Dist_On > 0.0 THEN\u000d\u000a\u000d\u000a\u0009\/\/ New travel distant must be smaller than the older value\u000d\u000a\u0009IF Travel_Dist_On < MyTS.Switchs[0].Travel.ToStart THEN\u000d\u000a\u0009\u0009\u000d\u000a\u0009\u0009\/\/ Update last travel distance\u000d\u000a\u0009\u0009 MyTS.Switchs[0].Travel.ToStart := Travel_Dist_On;\u000d\u000a\u000d\u000a\u0009\u0009\/\/ Compute SET timestamp\u000d\u000a\u0009\u0009Travel_Time_On := Travel_Dist_On \/ MyTS.Act.Vel;\u000d\u000a\u0009\u0009Travel_TS_On := MyTS.Act.TS_In + REAL_TO_ULINT(Travel_Time_On*1000000000.0);\u000d\u000a\u000d\u000a\u0009\u0009\/\/ Get timestamp offset (Init value - new computed TS) [ns]\u000d\u000a\u0009\u0009IF Travel_TS_On < MyTS.Switchs[0].TimeStamp.Start_Init THEN\u0009\u0009\/\/ OLD: IF Travel_TS_On < MyTS.Switchs[0].TimeStamp.Start THEN\u000d\u000a\u0009\u0009\u0009DeltaTS_On := - ULINT_TO_DINT(MyTS.Switchs[0].TimeStamp.Start_Init - Travel_TS_On);\u000d\u000a\u0009\u0009ELSE\u000d\u000a\u0009\u0009\u0009DeltaTS_On := ULINT_TO_DINT(Travel_TS_On - MyTS.Switchs[0].TimeStamp.Start_Init);\u000d\u000a\u0009\u0009END_IF;\u000d\u000a\u0009ELSE\u000d\u000a\u0009\u0009\/\/ Issue with wrap? Don't affect AVG\u000d\u000a\u0009\u0009DeltaTS_On := 0;\u000d\u000a\u0009END_IF;\u000d\u000a\u000d\u000a\u0009\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/   Average   \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\u000d\u000a\u000d\u000a\u0009\/\/ Add new delta to sum\u000d\u000a\u0009MyTS.Switchs[0].Avg.Sum_On := MyTS.Switchs[0].Avg.Sum_On + DINT_TO_LINT(DeltaTS_On);\u000d\u000a\u000d\u000a\u0009\/\/ The average is limited to 10 values\u000d\u000a\u0009IF MyTS.Switchs[0].Avg.Nb_On < 10 THEN\u000d\u000a\u0009\u0009Inc(MyTS.Switchs[0].Avg.Nb_On);\u000d\u000a\u0009ELSE\u000d\u000a\u0009\u0009\/\/ After 10 values, make a moving average\u000d\u000a\u0009\u0009MyTS.Switchs[0].Avg.Sum_On := MyTS.Switchs[0].Avg.Sum_On - DINT_TO_LINT(AvgTS_On);\u000d\u000a\u0009END_IF;\u000d\u000a\u000d\u000a\u0009\/\/ Compute average value\u000d\u000a\u0009AvgTS_On := LINT_TO_DINT( MyTS.Switchs[0].Avg.Sum_On \/ UINT_TO_LINT(MyTS.Switchs[0].Avg.Nb_On)) ;\u000d\u000a\u0009\u000d\u000aEND_IF;","W":1036,"X":1}],"CMT":"_______________________________________________________________________________________________________\u000a¦   Timestamp compensation computation                                                                                        ¦\u000a¦______________________________________________________________________________________________________¦\u000a\u000d\u000aComput time stamp offset with the On first point","LRI":2,"RRI":3,"VLs":[]}
{"CLs":[{"__type":"LD","Var":"Update_Off"},{"__type":"IST","EID":"492e6005-0306-4c3d-b3eb-1666e3319c65","H":594,"Ix":1,"TXT":"\/\/ Get the travel distance left to SET the output\u000d\u000aTravel_Dist_Off := MyTS.Switchs[0].PosEnd - MyTS.Act.Pos;\u000d\u000a\u000d\u000a\/\/ v01: Check if travel distance is calculed during a wrap-around\u000d\u000aIF Travel_Dist_Off > MyTS.Cfg.Modulo THEN\u000d\u000a\u0009Travel_Dist_Off := Travel_Dist_Off - MyTS.Cfg.Modulo;\u000d\u000aEND_IF;\u000d\u000a\u000d\u000a\/\/\/\/\/\/\/\/ Debug\u000d\u000aMyTS.Debug.Real_2 :=Travel_Dist_Off;\u000d\u000a\u000d\u000a\/\/ Travel distance must be positive\u000d\u000aIF Travel_Dist_Off > 0.0 THEN\u000d\u000a\u000d\u000a\u0009\/\/ New travel distant must be smaller than the older value\u000d\u000a\u0009IF Travel_Dist_Off < MyTS.Switchs[0].Travel.ToEnd THEN\u000d\u000a\u0009\u0009\u000d\u000a\u0009\u0009\/\/ Update last travel distance\u000d\u000a\u0009\u0009 MyTS.Switchs[0].Travel.ToEnd := Travel_Dist_Off;\u000d\u000a\u000d\u000a\u0009\u0009\/\/ Compute SET timestamp\u000d\u000a\u0009\u0009Travel_Time_Off := Travel_Dist_Off \/ MyTS.Act.Vel;\u000d\u000a\u0009\u0009Travel_TS_Off := MyTS.Act.TS_In + REAL_TO_ULINT(Travel_Time_Off*1000000000.0);\u000d\u000a\u000d\u000a\u0009\u0009\/\/ Get timestamp offset (Init value - new computed TS) [ns]\u000d\u000a\u0009\u0009IF Travel_TS_Off < MyTS.Switchs[0].TimeStamp.End_Init THEN\u000d\u000a\u0009\u0009\u0009DeltaTS_Off := - ULINT_TO_DINT(MyTS.Switchs[0].TimeStamp.End_Init - Travel_TS_Off);\u000d\u000a\u0009\u0009ELSE\u000d\u000a\u0009\u0009\u0009DeltaTS_Off := ULINT_TO_DINT(Travel_TS_Off - MyTS.Switchs[0].TimeStamp.End_Init);\u000d\u000a\u0009\u0009END_IF;\u000d\u000a\u0009ELSE\u000d\u000a\u0009\u0009\/\/ Issue with wrap? Don't affect AVG\u000d\u000a\u0009\u0009DeltaTS_Off := 0;\u000d\u000a\u0009END_IF;\u000d\u000a\u000d\u000a\u0009\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/   Average   \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\u000d\u000a\u000d\u000a\u0009\/\/ Add new delta to sum\u000d\u000a\u0009MyTS.Switchs[0].Avg.Sum_Off := MyTS.Switchs[0].Avg.Sum_Off + DINT_TO_LINT(DeltaTS_Off);\u000d\u000a\u000d\u000a\u0009\/\/ The average is limited to 10 values\u000d\u000a\u0009IF MyTS.Switchs[0].Avg.Nb_Off < 10 THEN\u000d\u000a\u0009\u0009Inc(MyTS.Switchs[0].Avg.Nb_Off);\u000d\u000a\u0009ELSE\u000d\u000a\u0009\u0009\/\/ After 10 values, make a moving average\u000d\u000a\u0009\u0009MyTS.Switchs[0].Avg.Sum_Off := MyTS.Switchs[0].Avg.Sum_Off - DINT_TO_LINT(AvgTS_Off);\u000d\u000a\u0009END_IF;\u000d\u000a\u000d\u000a\u0009\/\/ Compute average value\u000d\u000a\u0009AvgTS_Off := LINT_TO_DINT( MyTS.Switchs[0].Avg.Sum_Off \/ UINT_TO_LINT(MyTS.Switchs[0].Avg.Nb_Off)) ;\u000d\u000a\u0009\u000d\u000aEND_IF;","W":1002.9999999999999,"X":1}],"CMT":"Comput time stamp offset with the Off first point","LRI":2,"RRI":3,"VLs":[]}
{"CLs":[{"__type":"LD","Var":"Update_On"},{"__type":"IST","EID":"8ba59ae7-8098-4af1-90f8-3f5dfe8059d9","H":194,"Ix":1,"TXT":"\/\/ Apply correction to the start time stamp\u000d\u000aNewTS_On := MyTS.Switchs[0].TimeStamp.Start_Init + AvgTS_On ;\u000d\u000a\u000d\u000a\/\/ If update is possible, set order and new TS On value\u000d\u000aIF NewTS_On > MyTS.TSmin THEN\u000d\u000a\u0009MyTS.Switchs[0].TimeStamp.Start := NewTS_On;\u000d\u000a\u0009MyTS.Switchs[0].Sta.Set_On := FALSE;\u000d\u000aEND_IF;","W":823,"X":1}],"CMT":"__________________________________________________________________________________________________________________________________\u000d\u000a\u000d\u000aUpdate On timestamp","LRI":2,"RRI":3,"VLs":[]}
{"CLs":[{"__type":"LD","Var":"Update_Off"},{"__type":"IST","EID":"0e3f81a1-140d-484c-b8dd-2097a158dae5","H":198,"Ix":1,"TXT":"\/\/ Apply correction to the start time stamp\u000d\u000aNewTS_Off := MyTS.Switchs[0].TimeStamp.End_Init + AvgTS_Off ;\u000d\u000a\u000d\u000a\/\/ If update is possible, set order and new TS Off value\u000d\u000aIF NewTS_Off > MyTS.TSmin THEN\u000d\u000a\u0009MyTS.Switchs[0].TimeStamp.End := NewTS_Off;\u000d\u000a\u0009MyTS.Switchs[0].Sta.Set_Off := FALSE;\u000d\u000aEND_IF;","W":823,"X":1}],"CMT":"Update Off timestamp","LRI":2,"RRI":3,"VLs":[]}
