{"CLs":[{"__type":"LD","Var":"MyTS.Enable"},{"__type":"LD","Ix":1,"Var":"NewSwitch","X":1},{"__type":"F","In":[{"__type":"PF","Arg":"EN"},{"__type":"PRM","Arg":"In1","Ix":5,"Type":"ANY_ELEMENTARY(except BOOL)","Var":"MyTS.Num"},{"__type":"PRM","Arg":"In2","Ix":6,"Type":"ANY_ELEMENTARY(except BOOL)","Var":"MyTS.Cfg.Size"}],"Ix":16,"Name":"<","Out":[{"__type":"PF","Arg":""}],"X":2,"PL":true},{"__type":"F","In":[{"__type":"PF","Arg":"EN"},{"__type":"PRM","Arg":"InOut","IO":true,"Ix":11,"Type":"ANY_BIT(except BOOL)","Var":"MyTS.Error"},{"__type":"PRM","Arg":"Pos","Ix":12,"Type":"USINT","Var":"3"}],"Ix":18,"Name":"ResetABit","Out":[{"__type":"PF","Arg":"ENO"},{"__type":"PRM","Arg":"InOut","IO":true,"Ix":13,"Type":"ANY_BIT(except BOOL)","Var":"MyTS.Error"},{"__type":"PRM","Arg":"","Ix":14,"Type":"BOOL","Var":""}],"X":3},{"__type":"ST","Ix":2,"Var":"AddSwitch","X":4},{"__type":"F","In":[{"__type":"PF","Arg":"EN"},{"__type":"PRM","Arg":"In1","Ix":3,"Type":"ANY_ELEMENTARY, ENUM","Var":"MyTS.Num"},{"__type":"PRM","Arg":"In2","Ix":4,"Type":"ANY_ELEMENTARY, ENUM","Var":"MyTS.Cfg.Size"}],"Ix":15,"Name":"=","Out":[{"__type":"PF","Arg":""}],"X":2,"Y":1,"PL":true},{"__type":"F","In":[{"__type":"PF","Arg":"EN"},{"__type":"PRM","Arg":"InOut","IO":true,"Ix":7,"Type":"ANY_BIT(except BOOL)","Var":"MyTS.Error"},{"__type":"PRM","Arg":"Pos","Ix":8,"Type":"USINT","Var":"3"}],"Ix":17,"Name":"SetABit","Out":[{"__type":"PF","Arg":"ENO"},{"__type":"PRM","Arg":"InOut","IO":true,"Ix":9,"Type":"ANY_BIT(except BOOL)","Var":"MyTS.Error"},{"__type":"PRM","Arg":"","Ix":10,"Type":"BOOL","Var":""}],"X":3,"Y":1},{"__type":"HL","X":4,"Y":1}],"CMT":"Add switch order","LRI":19,"RRI":20,"VLs":[{"Ix":21,"X":2}]}
{"CLs":[{"__type":"LD","Var":"AddSwitch"},{"__type":"IST","EID":"c477227e-410a-434e-bd91-3b6d50cbff66","H":741,"Ix":1,"TXT":"\/\/ Compute switch start position\u000d\u000aIF PosAbs THEN\u000d\u000a\u0009\/\/ Absolute position - The start position is define with PosStart.\u000d\u000a\u0009Switch.PosStart := PosStart;\u000d\u000a\u0009TravelDist := PosStart - MyTS.Act.Pos;\u000d\u000a\u000d\u000a(*\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\/\/ Debug\u000d\u000a\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009MyTS.Debug.Real_2 := PosStart;*)\u000d\u000a\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u000d\u000a\u0009\/\/ If travel distance negative, we need to add a modulo to the absolute starting position\u000d\u000a\u0009IF TravelDist <= 0 THEN\u000d\u000a\u0009\u0009TravelDist := TravelDist + MyTS.Cfg.Modulo;\u000d\u000a\u0009\u0009Switch.PosStart := PosStart + MyTS.Cfg.Modulo;\u000d\u000a\u0009END_IF;\u000d\u000a\u0009\u000d\u000a\u0009\/\/ If travel distance is bigger than module -> Substract a module\u000d\u000a\u0009IF TravelDist >= MyTS.Cfg.Modulo THEN\u000d\u000a\u0009\u0009TravelDist := TravelDist - MyTS.Cfg.Modulo;\u000d\u000a\u0009END_IF;\u000d\u000a\u000d\u000aELSE\u000d\u000a\u0009\/\/ Relative position - The start position will be added to the current position of axis\u000d\u000a\u0009Switch.PosStart := MyTS.Act.Pos + PosStart;\u000d\u000a\u0009TravelDist :=PosStart;\u000d\u000aEND_IF;\u000d\u000a\u000d\u000a\/\/ Add length for pos OFF\u000d\u000aSwitch.PosEnd := Switch.PosStart + Length;\u000d\u000a\u000d\u000a(*\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\/\/ Debug\u000d\u000a\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009MyTS.Debug.TravelDist := TravelDist;\u000d\u000a\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009MyTS.Debug.Real_1 := MyTS.Act.Pos;\u000d\u000a\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009MyTS.Debug.Bool_1 := NOT MyTS.Debug.Bool_1;*)\u000d\u000a\u000d\u000a\/\/ Save current value when push is executed\u000d\u000aSwitch.Create := MyTS.Act;\u000d\u000aSwitch.Travel.ToStart := TravelDist;\u000d\u000aSwitch.Travel.ToEnd := TravelDist + Length;\u000d\u000a\u000d\u000a\/\/ Compute timestamp start time\u000d\u000aTravelTime := TravelDist \/ MyTS.Act.Vel;\u000d\u000aSwitch.TimeStamp.Start := MyTS.Act.TS_In+ REAL_TO_ULINT(TravelTime*1000000000.0);\u000d\u000a\u000d\u000a(*\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\/\/ Debug\u000d\u000a\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009MyTS.Debug.TravelTime := TravelTime;*)\u000d\u000a\u000d\u000a\/\/ Check if TS start is in limit\u000d\u000aIF Switch.TimeStamp.Start < MyTS.TSmin THEN\u000d\u000a\u0009 \/\/ Set the minimum value\u000d\u000a\u0009 Switch.TimeStamp.Start := MyTS.TSmin;\u000d\u000a\u0009 SetABit(MyTS.Error, 0);\u000d\u000aELSE\u000d\u000a\u0009 ResetABit(MyTS.Error, 0);\u000d\u000aEND_IF;\u000d\u000a\u000d\u000a\/\/ Compute timestamp end time\u000d\u000aTravelTime :=(TravelDist + Length) \/ MyTS.Act.Vel;\u000d\u000aSwitch.TimeStamp.End := MyTS.Act.TS_In + REAL_TO_ULINT(TravelTime*1000000000.0);\u000d\u000a\u000d\u000a\/\/ Check if TS end is in limit\u000d\u000aIF Switch.TimeStamp.End < MyTS.TSmin THEN\u000d\u000a\u0009 \/\/ Set the minimum value\u000d\u000a\u0009 Switch.TimeStamp.End := MyTS.TSmin;\u000d\u000a\u0009 SetABit(MyTS.Error, 1);\u000d\u000aELSE\u000d\u000a\u0009 ResetABit(MyTS.Error, 1);\u000d\u000aEND_IF;\u000d\u000a\u000d\u000a\/\/ Backup starting timestamp \u000d\u000aSwitch.TimeStamp.Start_Init := Switch.TimeStamp.Start;\u000d\u000aSwitch.TimeStamp.End_Init := Switch.TimeStamp.End;\u000d\u000a\u000d\u000a\/\/ Reset status\u000d\u000aSwitch.Sta.Set_On := FALSE;\u000d\u000aSwitch.Sta.Set_Off := FALSE;","W":972,"X":1}],"CMT":"Create new switch\u000d\u000a\u000d\u000aPosStart can be used in absolute position (the position to start the switch) or in relative (the distance to travel to start the switch).\u000d\u000a\u000d\u000aIn both case, it's not and issue if the starting position of the switch is greater than module, we juste need a this point a positive travel distance.","LRI":2,"RRI":3,"VLs":[]}
{"CLs":[{"__type":"LD","Var":"AddSwitch"},{"__type":"F","In":[{"__type":"PF","Arg":"EN"},{"__type":"PRM","Arg":"In","Ix":2,"Type":"ANY_ELEMENTARY, ENUM, STRUCT","Var":"Switch"},{"__type":"PRM","Arg":"InOut","IO":true,"Ix":3,"Type":"ANY_ELEMENTARY[], ENUM[], STRUCT[]","Var":"MyTS.Switchs[0]"},{"__type":"PRM","Arg":"Size","Ix":4,"Type":"UINT","Var":"MyTS.Cfg.Size"},{"__type":"PRM","Arg":"Num","IO":true,"Ix":5,"Type":"UINT","Var":"MyTS.Num"}],"Ix":9,"Name":"StackPush","Out":[{"__type":"PF","Arg":"ENO"},{"__type":"PRM","Arg":"","Ix":6,"Type":"BOOL","Var":""},{"__type":"PRM","Arg":"InOut","IO":true,"Ix":7,"Type":"ANY_ELEMENTARY[], ENUM[], STRUCT[]","Var":"MyTS.Switchs[0]"},{"__type":"PRM","Arg":"Num","IO":true,"Ix":8,"Type":"UINT","Var":"MyTS.Num"}],"X":1},{"__type":"ST","Ix":1,"Var":"ENO","X":2}],"CMT":"Stack the new switch","LRI":10,"RRI":11,"VLs":[]}
