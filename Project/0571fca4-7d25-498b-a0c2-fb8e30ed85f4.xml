{"CLs":[{"__type":"LD","Var":"P_First_Run"},{"__type":"F","In":[{"__type":"PF","Arg":"EN"},{"__type":"PRM","Arg":"In","Ix":1,"Type":"ANY","Var":"16#1"}],"Ix":5,"Name":"MOVE","Out":[{"__type":"PF","Arg":"ENO"},{"__type":"PRM","Arg":"Out","Ix":2,"Type":"ANY","Var":"Header[0]"}],"X":1},{"__type":"F","In":[{"__type":"PF","Arg":"EN"},{"__type":"PRM","Arg":"In","Ix":3,"Type":"ANY","Var":"16#17"}],"Ix":6,"Name":"MOVE","Out":[{"__type":"PF","Arg":"ENO"},{"__type":"PRM","Arg":"Out","Ix":4,"Type":"ANY","Var":"Terminator[0]"}],"X":1,"Y":1}],"CMT":"A standard serial communication message start with an header and finish with a terminator:\u000d\u000a<Header>My message<Terminator>\u000d\u000a\u000d\u000aTo simplify the management and the message creation, the configuration bloc will handle this! No action in the user side.\u000d\u000a\u000d\u000aExemple of configuration :\u000d\u000a- Header: SOH (0x01)\u000d\u000a- Terminator: ETB (0x17)","LRI":7,"RRI":8,"VLs":[{"Ix":9,"X":1}]}
{"CLs":[{"__type":"LD","Var":"P_On"},{"__type":"FB","In":[{"__type":"PRM","Arg":"In_Data_Type","Ix":1,"Type":"WORD","Var":"Serial_Input_Data_Type"},{"__type":"PRM","Arg":"In_Data_01","Ix":2,"Type":"ARRAY[0..3] OF BYTE","Var":"Serial_Input_Data_01"},{"__type":"PRM","Arg":"In_Data_02","Ix":3,"Type":"ARRAY[0..3] OF BYTE","Var":"Serial_Input_Data_02"},{"__type":"PRM","Arg":"In_Data_03","Ix":4,"Type":"ARRAY[0..3] OF BYTE","Var":"Serial_Input_Data_03"},{"__type":"PRM","Arg":"In_Data_04","Ix":5,"Type":"ARRAY[0..3] OF BYTE","Var":"Serial_Input_Data_04"},{"__type":"PRM","Arg":"In_Data_05","Ix":6,"Type":"ARRAY[0..3] OF BYTE","Var":"Serial_Input_Data_05"},{"__type":"PRM","Arg":"In_Data_Length","Ix":7,"Type":"UINT","Var":"Serial_Input_Data_Length"},{"__type":"PRM","Arg":"MySerial","IO":true,"Ix":8,"Type":"THE\\Serial","Var":"Serial_Device"},{"__type":"PRM","Arg":"In_SID","Ix":9,"Type":"USINT","Var":"Serial_Input_SID"},{"__type":"PRM","Arg":"In_SID_Response","IO":true,"Ix":10,"Type":"USINT","Var":"Serial_Input_SID_Response"},{"__type":"PRM","Arg":"Out_SID","IO":true,"Ix":11,"Type":"USINT","Var":"Serial_Output_SID"},{"__type":"PRM","Arg":"Out_SID_Response","Ix":12,"Type":"USINT","Var":"Serial_Output_SID_Response"},{"__type":"PF","Arg":"Enabled"},{"__type":"PRM","Arg":"NX_Ready","Ix":13,"Type":"BOOL","Var":"G99AP03_NX_Unit_Message_Enabled_Status"},{"__type":"PRM","Arg":"Header","Ix":14,"Type":"ARRAY[0..3] OF BYTE","Var":"Header"},{"__type":"PRM","Arg":"Terminator","Ix":15,"Type":"ARRAY[0..3] OF BYTE","Var":"Terminator"}],"Ix":26,"Name":"Serial_Config","Out":[{"__type":"PRM","Arg":"Out_Data_Type","Ix":16,"Type":"WORD","Var":"Serial_Output_Data_Type"},{"__type":"PRM","Arg":"Out_Data_01","Ix":17,"Type":"ARRAY[0..3] OF BYTE","Var":"Serial_Output_Data_01"},{"__type":"PRM","Arg":"Out_Data_02","Ix":18,"Type":"ARRAY[0..3] OF BYTE","Var":"Serial_Output_Data_02"},{"__type":"PRM","Arg":"Out_Data_03","Ix":19,"Type":"ARRAY[0..3] OF BYTE","Var":"Serial_Output_Data_03"},{"__type":"PRM","Arg":"Out_Data_04","Ix":20,"Type":"ARRAY[0..3] OF BYTE","Var":"Serial_Output_Data_04"},{"__type":"PRM","Arg":"Out_Data_05","Ix":21,"Type":"ARRAY[0..3] OF BYTE","Var":"Serial_Output_Data_05"},{"__type":"PRM","Arg":"Out_Data_Length","Ix":22,"Type":"UINT","Var":"Serial_Output_Data_Length"},{"__type":"PRM","Arg":"MySerial","IO":true,"Ix":23,"Type":"THE\\Serial","Var":"Serial_Device"},{"__type":"PF","Arg":"Busy"},{"__type":"PRM","Arg":"In_SID_Response","IO":true,"Ix":24,"Type":"USINT","Var":"Serial_Input_SID_Response"},{"__type":"PRM","Arg":"Out_SID","IO":true,"Ix":25,"Type":"USINT","Var":"Serial_Output_SID"}],"UD":true,"X":1,"Var":"Config"}],"CMT":"For the variable mapping of the CIF card, almost every variable is needed!\u000d\u000aNo need to map the \"children\" variable, it's managed with words in the FB.\u000d\u000a\u000d\u000aBefore starting the FB, we need to be sure every mapped variable are ready. To do this, we need the feedback from PLC that the card is ready to work.\u000d\u000aYou can map the \"Message_Enabled_Status\" for this information.\u000d\u000a\u000d\u000aThe buffer size on EtherCAT for in\/out message is only 5 arrays of 4 chars! It's mean the maximum message size between the PLC and the CIF card is 20 chars.\u000d\u000aFortunately, it's still possible to have larger messages! For example, in the case of an incoming message, I'll have the first 20 characters in the dataset, but also\u000d\u000athe \"In_SID\" variable will be incremented. Once the 20 characters have been saved in the block, I'll set \"In_SID_Response\" to the value of \"In_SID\". Once the information\u000d\u000ahas been sent to the card, it will send me the next 20 characters in the datas, and if there are still characters to send, the \"In_SID\" will be incremented again.\u000d\u000aIt's the same for a send message, but \"Out_SID\" and \"Out_SID_Response\". For more information, check W540 manual.\u000d\u000aEverting is already managed in \"Serial_Config\".","LRI":27,"RRI":28,"VLs":[]}
{"CLs":[{"__type":"ST","Var":"Info_Struct"}],"CMT":"Structure info:\u000d\u000aTo simplify the debug and running trace, i create an ID system. At startup, every \"Serial_xxx\" will take an ID (start at 1) and incremant the ID\u000d\u000afor the next FB. So, every FB will have a differant ID.\u000d\u000a\u000d\u000aAnd when a FB will be executed, it will write is ID in \"MyObject.Id_Order\" during the execution time, an put the value back to 0 when it's done.\u000d\u000aIf you trace this value, you can follow the execution order of FBs.","LRI":1,"RRI":2,"VLs":[]}
{"CLs":[{"__type":"ST","Var":"Info_General"}],"CMT":"There's a tool on Sysmac for tracing frames received by the card.\u000a\u000aGo to the PLC coupler or rack view, right-click on the CIF card, and click on \"CIF Serial line monitor\".","LRI":1,"RRI":2,"VLs":[]}
