<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>// Scaling on block from 0 to 10 pts &amp; calculation of the output &#xD;
&#xD;
//set the min max value, lower and upper behavior and units&#xD;
Apr_Struct.Param.Limit_X.Min:=Min_X;&#xD;
Apr_Struct.Param.Limit_X.Max:=Max_X;&#xD;
Apr_Struct.Param.Limit_Y.Min:=Min_Y;&#xD;
Apr_Struct.Param.Limit_Y.Max:=Max_Y;&#xD;
Apr_Struct.Param.Lower_behavior:=behavior_under_min_value;&#xD;
Apr_Struct.Param.Upper_behavior:=behavior_upper_max_value;&#xD;
Apr_Struct.Param.Unit_In:=Unit_X;&#xD;
Apr_Struct.Param.Unit_Out:=Unit_Y;&#xD;
&#xD;
IF Enable THEN // to do when block is enable register in an array the x&#xD;
My_array_point_X[0]:=Apr_Struct.Point[0].In;&#xD;
My_array_point_X[1]:=Apr_Struct.Point[1].In;&#xD;
My_array_point_X[2]:=Apr_Struct.Point[2].In;&#xD;
My_array_point_X[3]:=Apr_Struct.Point[3].In;&#xD;
My_array_point_X[4]:=Apr_Struct.Point[4].In;&#xD;
My_array_point_X[5]:=Apr_Struct.Point[5].In;&#xD;
My_array_point_X[6]:=Apr_Struct.Point[6].In;&#xD;
My_array_point_X[7]:=Apr_Struct.Point[7].In;&#xD;
My_array_point_X[8]:=Apr_Struct.Point[8].In;&#xD;
My_array_point_X[9]:=Apr_Struct.Point[9].In;&#xD;
My_setpoint:= Input; 	//&#xD;
Apr_Struct.Cmd.Setpoint := Input;&#xD;
ENO:=TRUE;&#xD;
END_IF;&#xD;
&#xD;
&#xD;
Enable_Trigger(Clk:=Enable, Q=&gt;My_Enable_trig);// trigger of enable value&#xD;
// if data not changed do not calculate the scaling&#xD;
Apr_Struct.Status.NB_point_Used:=0;&#xD;
&#xD;
	 FOR My_pointer_of_pts :=0 TO 9 DO //Calculate the number of point used&#xD;
&#xD;
	 	IF Apr_Struct.Point[My_pointer_of_pts].used =TRUE THEN // test if every point are used&#xD;
			Apr_Struct.Status.NB_point_Used :=Apr_Struct.Status.NB_point_Used+1;// increase the number of point used&#xD;
	 	END_IF;	  &#xD;
	 END_FOR;&#xD;
&#xD;
&#xD;
&#xD;
IF (Apr_Struct.Cmd.NewVal=true ) AND Enable=true THEN// calculate how many points are used in the graph&#xD;
&#xD;
// insert new point&#xD;
//Compare the new value to all old point&#xD;
//at the first it's inferior move the greaters value and add this one &#xD;
i:=0;&#xD;
&#xD;
		If Apr_Struct.Status.NB_point_Used &gt;=1 Then&#xD;
						For i:=0 To Apr_Struct.Status.NB_point_Used Do //find  where to insert the value&#xD;
							If (Apr_Struct.cmd.NewVal_X &lt; Apr_Struct.Point[i].In) Or Apr_Struct.Point[i].In=0 Then&#xD;
								Exit;&#xD;
							END_IF;	&#xD;
						END_FOR;&#xD;
&#xD;
						 FOR n:=8 To i BY -1 DO // shift the value trom the last till the inserted place&#xD;
						 	Apr_Struct.Point[n+1].In:= Apr_Struct.Point[n].In;&#xD;
							Apr_Struct.Point[n+1].out:= Apr_Struct.Point[n].out;&#xD;
							Apr_Struct.Point[n+1].Used:=Apr_Struct.Point[n].Used;&#xD;
						 END_FOR;&#xD;
				Apr_Struct.Point[i].In:=Apr_Struct.Cmd.NewVal_X;&#xD;
				Apr_Struct.Point[i].out :=Apr_Struct.Cmd.NewVal_Y; &#xD;
				Apr_Struct.Point[i].Used:=TRUE;&#xD;
		ELSE IF Apr_Struct.Status.NB_point_Used =0 Then&#xD;
				Apr_Struct.Point[0].In:=Apr_Struct.Cmd.NewVal_X;&#xD;
				Apr_Struct.Point[0].out :=Apr_Struct.Cmd.NewVal_Y; &#xD;
				Apr_Struct.Point[0].Used:=TRUE;&#xD;
		END_IF;		&#xD;
		END_IF; &#xD;
&#xD;
		Apr_Struct.Cmd.NewVal:=FALSE;// reset data change&#xD;
 &#xD;
END_IF;&#xD;
&#xD;
&#xD;
IF Apr_Struct.Cmd.Show_popup_delete THEN&#xD;
	IF Load_Value=FALSE THEN&#xD;
		Apr_Struct.Cmd.NewVal_X:=Apr_Struct.Point[Apr_Struct.Cmd.Delete_offset].IN;&#xD;
		Apr_Struct.Cmd.NewVal_Y:=Apr_Struct.Point[Apr_Struct.Cmd.Delete_offset].Out;&#xD;
	END_IF;&#xD;
	Load_Value:=TRUE;&#xD;
ELSE	&#xD;
		Load_Value:=FALSE;&#xD;
END_IF;&#xD;
&#xD;
IF Apr_Struct.Cmd.Delete_Val=1 then // delete a value &#xD;
	Apr_Struct.Point[Apr_Struct.Cmd.Delete_offset].In:=0;&#xD;
	// take the value from the next point&#xD;
		If Apr_Struct.Cmd.Delete_offset&lt;=8 Then&#xD;
			FOR i:=Apr_Struct.Cmd.Delete_offset To 8 DO//' (My_Apr.Status.NB_point_Used) 'find  where to insert the value&#xD;
		 		Apr_Struct.Point[i].In:= Apr_Struct.Point[i+1].In; &#xD;
				Apr_Struct.Point[i].out:= Apr_Struct.Point[i+1].out;&#xD;
				Apr_Struct.Point[i].Used:=Apr_Struct.Point[i+1].Used;&#xD;
		 		Apr_Struct.Point[i+1].In:=0;&#xD;
				Apr_Struct.Point[i+1].out:=0;&#xD;
				Apr_Struct.Point[i+1].Used:=False;&#xD;
			END_FOR;	 &#xD;
		END_IF;&#xD;
		IF Apr_Struct.Cmd.Delete_offset=9 Then &#xD;
		 		Apr_Struct.Point[9].In:=0;&#xD;
				Apr_Struct.Point[9].out:=0;&#xD;
				Apr_Struct.Point[9].Used:=False;			&#xD;
		END_IF;&#xD;
		Apr_Struct.Cmd.Delete_Val:=False;&#xD;
		Apr_Struct.Cmd.Delete_offset:=0;&#xD;
	END_IF;&#xD;
&#xD;
&#xD;
IF Apr_Struct.Cmd.Modify_Val THEN // value was modifie &#xD;
		//Save the value to the array&#xD;
		&#xD;
	IF   (Rec_Sort_Operating=FALSE) AND (Rec_Sort_operating_start=FALSE) THEN&#xD;
			Apr_Struct.Point[Apr_Struct.Cmd.Delete_offset].IN:=Apr_Struct.Cmd.NewVal_X;&#xD;
			Apr_Struct.Point[Apr_Struct.Cmd.Delete_offset].OUT:=Apr_Struct.Cmd.NewVal_Y;&#xD;
	END_IF; 	&#xD;
&#xD;
&#xD;
	Trigger_concatenation(Clk:= Apr_Struct.Cmd.Modify_Val, Q=&gt;Trigger_concatenation_out);&#xD;
&#xD;
	IF Apr_Struct.Cmd.Modify_Val THEN&#xD;
		Rec_Sort_operating_start:=TRUE;&#xD;
	END_IF;&#xD;
	&#xD;
	IF(Rec_Sort_operating_start=TRUE) THEN&#xD;
			RecSort_1(Execute:=FALSE,&#xD;
				  InOut:=Apr_Struct.Point[0], &#xD;
				  Member:=Apr_Struct.Point[0].IN);&#xD;
	END_IF;&#xD;
&#xD;
&#xD;
	IF Rec_Sort_operating_start=TRUE THEN&#xD;
		Rec_Sort_Operating:=TRUE;&#xD;
		Rec_Sort_operating_start:=FALSE;&#xD;
	END_IF; 	&#xD;
&#xD;
Timer_Rec_Sort(In:=(RecSort_done=true) , PT:=T#100ms);&#xD;
	IF (Rec_Sort_Operating=TRUE)  THEN&#xD;
	// check if the value have to move inside the array&#xD;
				Rec_Sort_operating_start:=FALSE;&#xD;
			RecSort_1(Execute:=TRUE,&#xD;
			  InOut:=Apr_Struct.Point[0], &#xD;
			  Size:=Apr_Struct.Status.NB_point_Used, &#xD;
			  Member:=Apr_Struct.Point[0].IN, &#xD;
			  Order:=_ASC, Done=&gt;RecSort_done, &#xD;
			  Busy=&gt;RecSort_busy, &#xD;
			  Error=&gt;RecSort_error);&#xD;
			&#xD;
	&#xD;
			IF ((RecSort_done=TRUE) OR (RecSort_error=TRUE)) AND Timer_Rec_Sort.q  THEN&#xD;
				Rec_Sort_Operating:=FALSE;&#xD;
				Apr_Struct.Cmd.Modify_Val:=FALSE;&#xD;
				Apr_Struct.Cmd.Delete_offset:=0;&#xD;
			END_IF;&#xD;
&#xD;
	&#xD;
	END_IF;&#xD;
&#xD;
END_IF;&#xD;
&#xD;
&#xD;
//second part chose the right scale&#xD;
&#xD;
IF (My_setpoint &gt;=Apr_Struct.Point[0].In) AND (My_setpoint&lt;=Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-1].In) AND Apr_Struct.Status.NB_point_Used&gt;=1 THEN // the input X is on the range of the graph&#xD;
	IF My_setpoint_compar&lt;&gt; My_setpoint then&#xD;
		AryCmpLEV(In1:=My_array_point_X[0], In2:=My_setpoint, Size:=Apr_Struct.Status.NB_point_Used, AryOut:=My_array_point_X_comp[0]); //compare x to the graph&#xD;
		My_setpoint_compar:=My_setpoint;&#xD;
	END_IF;&#xD;
	FOR My_pointer_of_value_calc:=0 TO Apr_Struct.Status.NB_point_Used DO // get on the array of bool the first operand at true&#xD;
	&#xD;
		IF My_array_point_X_comp[My_pointer_of_value_calc]= FALSE THEN // test if the value is true&#xD;
			My_pointer_of_value:=My_pointer_of_value_calc;&#xD;
			EXIT;// If it's true memorise the value and going out of the loop&#xD;
		ELSE;	&#xD;
		END_IF;	&#xD;
	END_FOR;&#xD;
	&#xD;
	Apr_Struct.Value:=ScaleTrans(SclIn:=Apr_Struct.Cmd.Setpoint, X0:=Apr_Struct.Point[My_pointer_of_value-1].In, Y0:=Apr_Struct.Point[My_pointer_of_value-1].OUT, X1:= Apr_Struct.Point[My_pointer_of_value_calc].In, Y1:= Apr_Struct.Point[My_pointer_of_value].Out, SclOfs:=0);&#xD;
	&#xD;
	&#xD;
	&#xD;
ELSE IF My_setpoint&lt;Apr_Struct.Point[0].In then // X is out of the range by the lower side&#xD;
// here 3 case 0= put 0 in the output 1=scale between the minimum limit value and the first point, 2= take the value at the lower point  &#xD;
&#xD;
 CASE Apr_Struct.Param.Lower_behavior OF&#xD;
	 0:&#xD;
		 Apr_Struct.Value:=0;&#xD;
	 	1:&#xD;
	 	Apr_Struct.Value:=ScaleTrans(SclIn:=Apr_Struct.Cmd.Setpoint, X0:=Apr_Struct.Param.Limit_X.Min, Y0:=Apr_Struct.Param.Limit_Y.Min, X1:=Apr_Struct.Point[0].In, Y1:= Apr_Struct.Point[0].Out, SclOfs:=0);&#xD;
		2:&#xD;
	 	Apr_Struct.Value:=Apr_Struct.Point[0].Out;&#xD;
 		3:	&#xD;
	 	Apr_Struct.Value:=ScaleTrans(SclIn:=Apr_Struct.Cmd.Setpoint, X0:=Apr_Struct.Point[0].In, Y0:=Apr_Struct.Point[0].Out, X1:=Apr_Struct.Point[1].In, Y1:= Apr_Struct.Point[1].Out, SclOfs:=0);&#xD;
	&#xD;
		//Apr_Struct.Status.Value_A_for_min:= (Apr_Struct.Point[1].Out / ((Apr_Struct.Point[1].Out-Apr_Struct.Point[0].Out)/(Apr_Struct.Point[1].In-Apr_Struct.Point[0].In)))+Apr_Struct.Point[0].In;&#xD;
	&#xD;
 	ELSE&#xD;
	 	 Apr_Struct.Value:=0;&#xD;
 END_CASE;&#xD;
&#xD;
ELSE IF My_setpoint&gt;Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-1].In then // X is outside of the range by the Upper side&#xD;
// here 3 case 0= put 0 in the output 1=scale between the minimum limit value and the first point, 2= take the value at the upper point  &#xD;
&#xD;
 CASE Apr_Struct.Param.Upper_behavior OF&#xD;
	 0:&#xD;
	 	Apr_Struct.Value :=0;&#xD;
	 1:&#xD;
	 	Apr_Struct.Value:=ScaleTrans(SclIn:=Apr_Struct.Cmd.Setpoint, X0:=Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-1].In, Y0:=Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-1].Out, X1:= Apr_Struct.Param.Limit_X.Max , Y1:= Apr_Struct.Param.Limit_Y.Max, SclOfs:=0);&#xD;
	 2:&#xD;
	 	Apr_Struct.Value:=Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-1].Out;&#xD;
	 3:&#xD;
	 	Apr_Struct.Value:=ScaleTrans(SclIn:=Apr_Struct.Cmd.Setpoint, X0:=Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-2].In, Y0:=Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-2].Out, X1:= Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-1].In , Y1:= Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-1].Out, SclOfs:=0);&#xD;
&#xD;
&#xD;
		&#xD;
&#xD;
		IF Apr_Struct.Status.Value_max_for_X&lt; Apr_Struct.Param.Limit_Y.Min THEN&#xD;
	 		 Apr_Struct.Status.Value_max_for_X:=Apr_Struct.Param.Limit_Y.Min;&#xD;
		END_IF;&#xD;
		&#xD;
		IF Apr_Struct.Status.Value_max_for_X&gt; Apr_Struct.Param.Limit_Y.Max THEN&#xD;
			Apr_Struct.Status.Value_max_for_X:= Apr_Struct.Param.Limit_Y.Max;&#xD;
		END_IF	;&#xD;
	 &#xD;
		 &#xD;
 	ELSE&#xD;
	 	Apr_Struct.Value:=0;&#xD;
 END_CASE;&#xD;
&#xD;
END_IF;END_IF;END_IF;	&#xD;
&#xD;
IF Apr_Struct.Status.NB_point_Used&gt;=2 then&#xD;
&#xD;
		IF Apr_Struct.Point[0].OUT&gt;Apr_Struct.Status.Value_min_for_X Then&#xD;
			Apr_Struct.Status.Value_A_for_min:= (Apr_Struct.Param.Limit_Y.Min-Apr_Struct.Point[1].Out)*((Apr_Struct.Point[0].In- Apr_Struct.Point[1].In)/(Apr_Struct.Point[0].Out-Apr_Struct.Point[1].Out))+Apr_Struct.Point[1].In;&#xD;
		END_IF;&#xD;
		IF Apr_Struct.Point[0].OUT&lt;Apr_Struct.Status.Value_min_for_X Then&#xD;
			Apr_Struct.Status.Value_A_for_min:= (Apr_Struct.Param.Limit_Y.Max-Apr_Struct.Point[1].Out)*((Apr_Struct.Point[0].In- Apr_Struct.Point[1].In)/(Apr_Struct.Point[0].Out-Apr_Struct.Point[1].Out))+Apr_Struct.Point[1].In;&#xD;
		END_IF;&#xD;
	&#xD;
		&#xD;
		IF Apr_Struct.Status.Value_A_for_min&lt;0 OR Apr_Struct.Status.Value_A_for_min&gt; Apr_Struct.Param.Limit_X.Max THEN&#xD;
			Apr_Struct.Status.Value_A_for_min:=0;&#xD;
		END_IF;	&#xD;
&#xD;
&#xD;
		IF Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-1].OUT&gt;=Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-2].OUT THEN&#xD;
			Apr_Struct.Status.Value_A_for_max:= (Apr_Struct.Param.Limit_Y.Max-Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-1].Out)*((Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-2].In- Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-1].In)/(Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-2].Out-Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-1].Out))+Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-1].In;&#xD;
		END_IF;&#xD;
		IF Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-1].OUT=Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-2].OUT THEN&#xD;
			Apr_Struct.Status.Value_A_for_max:=Apr_Struct.Param.Limit_X.Max;&#xD;
		END_IF;&#xD;
	&#xD;
		IF Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-2].OUT&gt;Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-1].OUT THEN&#xD;
			Apr_Struct.Status.Value_A_for_max:= (Apr_Struct.Param.Limit_Y.Min-Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-1].Out)*((Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-2].In- Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-1].In)/(Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-2].Out-Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-1].Out))+Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-1].In;&#xD;
		END_IF;	&#xD;
END_IF;&#xD;
&#xD;
&#xD;
&#xD;
Apr_Struct.Status.Value_min_for_X:=ScaleTrans(SclIn:=Apr_Struct.Param.Limit_X.Min, X0:=Apr_Struct.Point[0].In, Y0:=Apr_Struct.Point[0].Out, X1:=Apr_Struct.Point[1].In, Y1:= Apr_Struct.Point[1].Out, SclOfs:=0);&#xD;
&#xD;
Apr_Struct.Status.Value_max_for_X:=ScaleTrans(SclIn:=Apr_Struct.Param.Limit_X.Max, X0:=Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-2].In, Y0:=Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-2].Out, X1:=Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-1].In, Y1:= Apr_Struct.Point[Apr_Struct.Status.NB_point_Used-1].Out, SclOfs:=0);&#xD;
&#xD;
IF Apr_Struct.Status.Value_min_for_X&lt; Apr_Struct.Param.Limit_Y.Min THEN&#xD;
	 Apr_Struct.Status.Value_min_for_X:= Apr_Struct.Param.Limit_Y.Min;&#xD;
ELSE IF  Apr_Struct.Status.Value_min_for_X&gt; Apr_Struct.Param.Limit_Y.Max THEN&#xD;
	Apr_Struct.Status.Value_min_for_X:= Apr_Struct.Param.Limit_Y.Max ;&#xD;
END_IF;END_IF;	&#xD;
&#xD;
IF Apr_Struct.Status.Value_max_for_X&lt; Apr_Struct.Param.Limit_Y.Min THEN&#xD;
	 Apr_Struct.Status.Value_max_for_X:= Apr_Struct.Param.Limit_Y.Min;&#xD;
ELSE IF  Apr_Struct.Status.Value_max_for_X&gt; Apr_Struct.Param.Limit_Y.Max THEN&#xD;
	Apr_Struct.Status.Value_max_for_X:= Apr_Struct.Param.Limit_Y.Max ;&#xD;
END_IF;END_IF;	&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
IF Apr_Struct.Value&gt; Apr_Struct.Param.Limit_Y.Max THEN&#xD;
	 Apr_Struct.Value:= Apr_Struct.Param.Limit_Y.Max;&#xD;
END_IF;&#xD;
&#xD;
IF Apr_Struct.Value&lt; Apr_Struct.Param.Limit_Y.Min THEN&#xD;
	 Apr_Struct.Value:= Apr_Struct.Param.Limit_Y.Min;&#xD;
END_IF;&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
</Text></StructuredTextModel>